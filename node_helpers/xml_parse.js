/** 
 * XML Parse Module
 * @module modules/xml_parse
 *
 * This file provides the feature to parse XML outputs of ZAP into JSON.
 * <MODULES>
 * NPM Modules (3rd party imported):
 *     Xml2js: Simple XML to JavaScript object converter.
 * 			   (https://www.npmjs.com/package/xml2js)
 * 
 * Author : David Song (deokwons9004dev@gmail.com)
 * Version: 16-11-30 (YY-MM-DD)
 */

/* Native Module Import */
var fs  = require("fs");
var log = console.log.bind(this);

/* NPM Module Import */
var xmljs = require("xml2js");

/**
 * Parses a XML Report to a JSON Array.
 * IMPORTANT: This function only works for XML files 
 *            generated by OWASP ZAP.
 * 
 * @param {object}   socket : Current web socket.
 * @param {string}   xmlpath: The XML file path.
 * @param {function} callback
 *                   	1st Arg: Error
 *                      2nd Arg: Result Array 
 */
exports.parseXML = function (socket, xmlpath, callback) {
	/* Read the XML file as UTF-8 text. */
	var xmlfile = fs.readFileSync(xmlpath, "utf8");
	/* Result Array to return. */
	var scan    = [];
	/* Spawn a new XML2JS Parse Object. */
	var parser  = new xmljs.Parser();
	
	/* Remove the report file since we don't need it anymore. */
	fs.unlinkSync(xmlpath);
	
	/* Parse the XML text into JSON and refine 
	 * the data to fit our purposes. 
	 */
	parser.parseString(xmlfile, function (error, result) {
		if (error) return callback(error);
		else if (result.OWASPZAPReport == undefined)      return callback('EMPTY_REPORT');
		else if (result.OWASPZAPReport.site == undefined) return callback('EMPTY_SITE_REPORT');
		else {
			/* Notify client that parsing began. */
			socket.emit('progress_zap_6_parse_start');
			/* ZAP reports crawl through multiple sub directories of the website. 
			 * Vulnerabilities are categorized by the site it occurred. 
			 * So we have to go through each site's result and extract data. 
			 */			
			result.OWASPZAPReport.site.forEach(function (site, site_id) {
				if (site.alerts[0].alertitem != undefined) {
					/* Each site contains alert items (possible vulnerabilities), 
					 * so we extract crucial parts of these data and copy them to 
					 * a JSON object which will be pushed into the result array. 
					 */
					site.alerts[0].alertitem.forEach(function (item, item_id) { // The actual alert items.
						
						var vul = {};
						
						vul.alert = item.alert[0];
						vul.risklevel = item.riskcode[0];
						vul.risktext = item.riskdesc[0];
						
						vul.instances = [];
						vul.count = item.count[0];
						item.instances[0].instance.forEach(function (url, i) {
							vul.instances.push(url.uri[0]);
						});
						
						vul.description = (item.desc != undefined ? item.desc[0] : '');
						vul.solution = (item.solution != undefined ? item.solution[0] : '');
						vul.info = (item.otherinfo != undefined ? item.otherinfo[0] : '');
						vul.ref = (item.reference != undefined ? item.reference[0] : '');
						
						scan.push(vul);
					});
				}
			});
			/* Notify the client that the parsing is complete. */
			socket.emit('progress_zap_7_parse_done');
			/* Return callback. */
			return callback(undefined, scan);
		}
	});
}

